#!/usr/bin/env escript
%% -*- erlang -*-

main([ Type, In ]) ->
    Erl = srcfile(In),
    case uptodate(In, filename:join([basedir(), Erl])) of
	true -> ok;
	false -> 
	    io:format("Generated ~s~n", [Erl]),
	    generate(erl, Type, read(In), filename:join([basedir(), Erl]))
    end,
    Hrl = hrlfile(In),
    case uptodate(In, filename:join([basedir(), Hrl])) of
	true -> ok;
	false -> 
	    io:format("Generated ~s~n", [Hrl]),
	    generate(hrl, Type, read(In), filename:join([basedir(), Hrl]))
    end;
main(_) ->
    io:format(usage()).

usage() ->
    io_lib:format("Usage: ~p {nss|attrs|elems} file.in~n",
		  [filename:basename(escript:script_name())]).

generate(hrl, "nss", Terms, Out) ->
    write(terms_to_hrl("XMPP_KNOWN_NSS", Terms), Out);
generate(erl, "nss", Terms, Out) ->
    write(terms_to_erl("exmpp_known_nss", "ns_as_list", Terms), Out);
generate(hrl, "attrs", Terms, Out) ->
    write(terms_to_hrl("XMPP_KNOWN_ATTRS", Terms), Out);
generate(erl, "attrs", Terms, Out) ->
    write(terms_to_erl("exmpp_known_attrs", "attr_as_list", Terms), Out);
generate(hrl, "elems", Terms, Out) ->
    write(terms_to_hrl("XMPP_KNOWN_ELEMS", Terms), Out);
generate(erl, "elems", Terms, Out) ->
    write(terms_to_erl("exmpp_known_elems", "elem_as_list", Terms), Out);
generate(_,_,_, _) ->
    throw({error, invalid_args}).

write(Str, Outfile) ->
    case file:open(Outfile, [write]) of
	{ok, Io} ->
	    io:fwrite(Io, "% Generated by ~p on ~s~n", [filename:basename(escript:script_name()),
							time_to_str(erlang:now())]),
	    io:fwrite(Io, 
		      "% File: ~s~n"
		      "% ~n", 
		      [filename:basename(Outfile)]),
	    io:fwrite(Io, Str, []);
	{error, Err} ->
	    io:format("IO Error: ~p~n", [Err])
    end.

terms_to_erl(Mod, Fun, Terms) ->
    S = [ io_lib:format("-module(~s).~n"
			"-export([~s/1]).~n~n", [Mod, Fun]) ],
    S2 = sets:fold(fun (NSbin, Acc) ->
			   NS = to_atom(NSbin),
			   [ io_lib:format("~s('~s') -> \"~s\";~n", [Fun, NS, NS]) | Acc ]
		   end, S, Terms),
    S3 = [ io_lib:format("~s(undefined) -> \"\";~n", [Fun]) | S2 ],
    S4 = [ io_lib:format("~s(A) when is_atom(A) -> atom_to_list(A);~n", [Fun]) | S3 ],
    S5 = [ io_lib:format("~s(S) when is_list(S) -> S.~n~n", [Fun]) | S4 ],
    lists:reverse(S5).

terms_to_hrl(Def, Terms) ->
    io_lib:format("-define(~s,~n"
		  "        ~p).~n~n",
		  [ Def, [ to_atom(Term) || Term <- sets:to_list(Terms) ] ]).

read(Src) ->
    {ok, Bin} = file:read_file(Src),
    read_line(Bin, <<>>, sets:new()).

read_line(<<>>, _, T) ->
    T;
read_line(<< $#, Rest/bits >>, <<>>, T) ->
    read_comment(Rest, <<>>, T);
read_line(<< $\n, Rest/bits >>, <<>>, T) ->
    read_line(Rest, <<>>, T);
read_line(<< C, Rest/bits >>, A, T) ->
    case C of
	$\n -> read_line(Rest, <<>>, sets:add_element(A, T));
	$\s -> read_line(Rest, A, T);
	$\t -> read_line(Rest, A, T);
	C -> read_line(Rest, << A/binary, C >>, T)
    end.

read_comment(<< $\n, Rest/bits >>, A, T) ->
    read_line(Rest, A, T);
read_comment(<< _, Rest/bits >>, A, T) ->
    read_comment(Rest, A, T).

time_to_str(Time) ->
    {{Y,Mo,D},{H,M,S}} = calendar:now_to_datetime(Time),
    io_lib:format("~p-~p-~p, ~p:~p:~p UTC", [Y, Mo, D, H, M, S]).

basedir() ->
    filename:join([filename:dirname(escript:script_name()), ".."]).

includedir() ->
    filename:join(["include", "internal"]).

srcdir() ->
    "src".

hrlfile(File) ->
    filename:join([includedir(), filename:basename(File, ".in")]) ++ ".hrl".

srcfile(File) ->
    filename:join([srcdir(), filename:basename(File, ".in")]) ++ ".erl".

to_atom(Bin) when is_binary(Bin) ->
    binary_to_atom(Bin, utf8).

uptodate(Src, Dest) ->
    case file:read_file_info(Dest, [{time, posix}]) of
	{error, enoent} -> false;
	{error, Err} -> throw({error, Err});
	{ok, {file_info, _, _, _, _, DestMTime, _, _, _, _, _, _, _, _}} ->
	    case file:read_file_info(Src, [{time, posix}]) of
		{error, Err} -> throw({error, Err});
		{ok, {file_info, _, _, _, _, SrcMTime, _, _, _, _, _, _, _, _}} ->
			if SrcMTime>DestMTime -> false;
			   true -> true
			end
	    end
    end.
